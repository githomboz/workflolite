<?php

require_once 'Meta.php';
require_once 'WorkflowFactory.php';

class Job extends WorkflowFactory
{

  /**
   * The collection that this record belongs to
   * @var string
   */
  protected static $_collection = 'jobs';

  private $tasks = array();

  private $sortOrder = array();

  /**
   * Meta class
   * @var null Meta
   */
  private $meta = null;

  protected static $_contactsField = 'partiesInvolved';

  public function __construct(array $data)
  {
    parent::__construct();
    $this->_initialize($data);
    $this->meta = new Meta($data['meta'], $this);
  }

  public function _initialize(array $data)
  {
    parent::_initialize($data); // TODO: Change the autogenerated stub
    $this->sortOrder = $this->getValue('sortOrder');
  }

  public function addTask(Task $task){
    if($this->hasId()){
      $task->setValues(array('jobId' => $this->id()))->save();
      $this->tasks[] = $task;
      $this->sort();
      return $this;
    } else {
      throw new Exception('Tasks can not be added without an _id');
    }
  }

  public function addNote($noteData){
    $success = false;
    $notes = $this->getNotes();
    $duplicate = false;
    $ids = array();
    if(!empty($notes)){
      $notesJSON = array();
      foreach($notes as $i => $note) {
        unset($note['datetime']);
        if(!empty($note) && !isset($note['id'])) {
          do {
            // generate id
            $id = _generate_id(6);
          } while(in_array($id, $ids)); // Check if unique

          // set id
          $notes[$i]['id'] = $id;
        }
        ksort($note);
        unset($note['id']);
        $notesJSON[] = json_encode($note);
        $ids[] = $notes[$i]['id'];
      }

      $testData = $noteData;
      do {
        // generate id
        $noteData['id'] = _generate_id(6);
      } while(in_array($noteData['id'], $ids)); // Check if unique

      unset($testData['datetime']);
      ksort($testData);
      $testData = json_encode($testData);

      foreach($notesJSON as $i => $noteJSON) {
        //var_dump('$testData: ' . $testData, '$noteJSON: '. $noteJSON);
        if($noteJSON == $testData) $duplicate = true;
      }

    }

    if(!$duplicate){
      $notes[] = $noteData;
      $success = $this->setNotesArray($notes);
    }

    return $noteData['id'];
  }

  public function deleteNote($noteId){
    $notes = $this->getNotes();
    foreach($notes as $i => $note) {
      if($note['id'] == $noteId) {
        unset($notes[$i]);
      }
    }
    return $this->setNotesArray($notes);
  }

  public function getNotes(){
    // Check if id is set
    $changed = false;
    $notes = $this->getValue('notes');
    $ids = array();
    if(!empty($notes)){
      foreach($notes as $i => $note) {
        if(!empty($note) && !isset($note['id'])){
          do {
            // generate id
            $notes[$i]['id'] = _generate_id(6);
          } while(in_array($notes[$i]['id'], $ids)); // Check if unique
          $changed = true;
        }
      }
    }
    if($changed) $this->setNotesArray($notes);
    return $notes;
  }

  public function setNotesArray($notes){
    sortBy('datetime', $notes, 'desc');
    return $this->setValue('notes', $notes)->save('notes');
  }

  public function searchNotes($term){
    $results = array();
    $inResults = array();
    foreach($this->getNotes() as $i => $note){
      if(strpos(strtolower($note['content']), strtolower($term)) !== false) {
        $results[] = $note;
        $inResults[] = json_encode($note);
      }
      if(!empty($note['tags'])){
        foreach($note['tags'] as $t => $tag){
          if(strpos(strtolower($tag), strtolower($term)) !== false && !in_array(json_encode($note), $inResults)) $results[] = $note;
        }
      }
    }
    return $results;
  }

  public function getNoteTags(){
    $results = array();
    foreach((array) $this->getNotes() as $i => $note){
      if(!empty($note['tags'])){
        foreach($note['tags'] as $t => $tag){
          if(!isset($results[$tag])) $results[$tag] = 0;
          $results[$tag] ++;
        }
      }
    }
    arsort($results);
    return $results;
  }

  public function displayDetails(){
    $data = array(
    );

    return $data;
  }

  public function acknowledgeTask(Task $task){
    $this->tasks[] = $task;
    if(!in_array((string) $task->id(), $this->sortOrder)){
      $this->sortOrder[] = $task->id();
    }
  }

  public function sort(){
    $reorderedTasks = array();
    foreach((array) $this->sortOrder as $order => $id){
      foreach($this->tasks as $i => $task){
        if((string) $task->id() == (string) $id) $reorderedTasks[] = $task;
      }
    }
    $this->tasks = $reorderedTasks;
    return $this;
  }

  /**
   * Insert given task after the provided task
   * @param $taskId ID of the task being added
   * @param $afterTaskId The id of the task that will precede the given task
   */
  public function insertTaskAfter($taskId, $afterTaskId){
    $position = array_search((string) $afterTaskId, $this->sortOrder);
    array_splice($this->sortOrder, ($position+1), 0, array( _id($taskId)));
  }

  public function saveSortOrder(){
    if(json_encode($this->sortOrder) != json_encode($this->getValue('sortOrder'))){
      self::Update($this->id(), array(
        'sortOrder' => $this->sortOrder
      ));
    }
  }

  public function getAllTasks($grouped = false){
    if($this->hasId()){
      if(!empty($this->tasks)) return $this->tasks;
      else {
        $tasks = self::CI()->mdb->where('jobId', $this->id())->get(Task::CollectionName());
        foreach($tasks as $i => $task) $this->acknowledgeTask(new Task($task));
        $this->saveSortOrder();
        $this->sort();
        return $this->tasks;
      }
    } else {
      throw new Exception('Tasks can not be pulled without an _id');
    }
  }

  /**
   * Return all tasks that can be executed for the current job
   * @param bool $grouped Whether or not to return in an associated array grouped by "taskGroup"
   * @return array List of Task objects
   */
  public function getActionableTasks($grouped = false){
    $actionable = array();
    foreach($this->getAllTasks() as $i => $task){
      if($task->isActionable()) {
        if($grouped){
          if(!isset($actionable[$task->getValue('taskGroup')])) $actionable[$task->getValue('taskGroup')] = array();
          $actionable[$task->getValue('taskGroup')][] = $task;
        } else {
          $actionable[] = $task;
        }
      }
    }
    return $actionable;
  }

  /**
   * Return all tasks that can be displayed executed for the current job
   * @param bool $grouped Whether or not to return in an associated array grouped by "taskGroup"
   * @return array List of Task objects
   */
  public function getShowableTasks($grouped = false){
    $actionable = array();
    foreach($this->getAllTasks() as $i => $task){
      if($task->isShowable()) {
        if($grouped){
          if(!isset($actionable[$task->getValue('taskGroup')])) $actionable[$task->getValue('taskGroup')] = array();
          $actionable[$task->getValue('taskGroup')][] = $task;
        } else {
          $actionable[] = $task;
        }
      }
    }
    return $actionable;
  }

  /**
   * Return all tasks that can be displayed executed for the current job
   * @param bool $grouped Whether or not to return in an associated array grouped by "taskGroup"
   * @return array List of Task objects
   */
  public function getClientViewableTasks($grouped = false){
    $actionable = array();
    foreach($this->getAllTasks() as $i => $task){
      if($task->isClientViewable()) {
        if($grouped){
          if(!isset($actionable[$task->getValue('taskGroup')])) $actionable[$task->getValue('taskGroup')] = array();
          $actionable[$task->getValue('taskGroup')][] = $task;
        } else {
          $actionable[] = $task;
        }
      }
    }
    return $actionable;
  }

  public function getNextTask(){
    foreach($this->getActionableTasks() as $i => $task){
      return $task;
    }
  }

  public function stats(){
    return self::CompletionStats($this->getShowableTasks());
  }

  public static function CompletionStats(array $taskSet){
    $stats = array(
      'total' => 0,
      'completed' => 0,
      'deleted' => 0,
      'skipped' => 0,
      'forceSkipped' => 0,
      'completionPercentage' => 0,
      'totalEstimatedTime' => 0,
      'completedTime' => 0
    );
    foreach($taskSet as $task) {
      $stats['total'] ++;
      if($task->isComplete()) {
        $stats['completed'] ++;
        $stats['completedTime'] += (float) $task->getValue('estimatedTime');
      }
      if($task->isSkipped()) $stats['skipped'] ++;
      if($task->isForceSkipped()) $stats['forceSkipped'] ++;
      if($task->isDeleted()) $stats['deleted'] ++;
      $stats['totalEstimatedTime'] += (float) $task->getValue('estimatedTime');
    }
    $stats['completionPercentage'] = round(($stats['completed']/$stats['total']) * 100);
    return $stats;
  }

  public static function CompletionPercentage(array $taskSet){
    $stats = self::CompletionStats($taskSet);
    return $stats['completionPercentage'];
  }

  public function getContacts(){
    $contacts = $this->getValue(self::$_contactsField);
    $roles = array();
    $contactIds = array();
    $userIds = array();
    foreach($contacts as $contact) {
      $userType = null;
      if(isset($contact['contactId'])) {
        $contactIds[] = $contact['contactId'];
        $userType = 'contactId';
      }
      if(isset($contact['userId'])) {
        $userIds[] = $contact['userId'];
        $userType = 'userId';
      }
      $roles[(string) $contact[$userType]] = $contact['role'];
    }
    $contacts = Contact::GetByIds($contactIds);
    $users = User::GetByIds($userIds);
    foreach($contacts as $i => $contact) if(isset($roles[(string) $contact->id()])) $contacts[$i]->setValue('role', $roles[(string) $contact->id()]);
    foreach($users as $i => $user) if(isset($roles[(string) $user->id()])) $users[$i]->setValue('role', $roles[(string) $user->id()]);

    return array_merge($contacts, $users);
  }

  /**
   * Get task object from tasks list instead of calling from db
   * @param $id
   * @return bool|mixed
   */
  public function getTaskById($id){
    foreach($this->tasks as $task) if((string) $task->id() == (string) $id) return $task;
    return false;
  }

  public function getCurrentTask(){
    $tasks = $this->getActionableTasks();
    foreach($tasks as $task) if(!$task->isComplete()) return $task;
  }
  
  public function getMeta(){
    return $this->meta->getAll();
  }

  public function getRawMeta(){
    return $this->getValue('meta');
  }

  public function addContactById($contact_or_user_id, $role, $isClient = false, $isContact = true){
    $contactsField = 'partiesInvolved';
    $contacts = $this->getValue($contactsField);
    $contacts = array_values($contacts);
    $userType = $isContact ? 'contactId' : 'userId';
    $contacts[] = array(
      $userType => _id($contact_or_user_id),
      'role' => $role,
      'isClient' => (bool) $isClient,
    );
    $this->setValue($contactsField, $contacts)->save($contactsField);
    return $this;
  }

  /**
   * Check if the passed id is a contact of $this job
   * @param $contact_or_user_id
   * @param bool $isContact
   * @return bool
   */
  public function isContact($contact_or_user_id, $isContact = true){
    $contactsField = 'partiesInvolved';
    $contacts = $this->getValue($contactsField);
    $userType = $isContact ? 'contactId' : 'userId';
    foreach($contacts as $contact) if((string) $contact[$userType] == (string) $contact_or_user_id) return true;
    return false;
  }

  public function removeContact($contactId){
    $save = false;
    $contactsField = 'partiesInvolved';
    $contacts = $this->getValue($contactsField);
    foreach($contacts as $i => $contact){
      if($contact['contactId'] == _id($contactId)) {
        $save = true;
        unset($contacts[$i]);
      }
    }
    if($save){
      $this->setValue($contactsField, $contacts)->save($contactsField);
    }
    return $this;
  }

  public function updateContactRole($contactId, $role){
    $save = false;
    $contactsField = 'partiesInvolved';
    $contacts = $this->getValue($contactsField);
    foreach($contacts as $i => $contact){
      if($contact['contactId'] == _id($contactId)) {
        $save = true;
        $contacts[$i]['role'] = $role;
      }
    }
    if($save){
      $this->setValue($contactsField, $contacts)->save($contactsField);
    }
    return $this;
  }

  public function getUrl(){
    return site_url('jobs/' . $this->id() . '/tasks');
  }

  public static function Get($id){
    $record = static::LoadId($id, static::$_collection);
    $class = __CLASS__;
    return new $class($record);
  }

  public function saveAsTemplate($name, $description = "", $group = "General"){
    $this->loadWorkflow();
    $newWorkflow = array(
      'name' => $name,
      'description' => $description,
      'organizationId' => UserSession::Get_Organization()->id(),
      'group' => $group ? $group : $this->workflow->getValue('group'),
      'roles' => $this->workflow->getValue('roles'),
      'status' => 'active',
      'taskTemplates' => array(),
      'accessibility' => array(),
      'metaFields' => $this->workflow->getValue('metaFields'),
    );

    // Add Task Templates
    $tasks = $this->getAllTasks();
    foreach($tasks as $task) $newWorkflow['taskTemplates'][] = $task->getValue('taskTemplateId');
    $id = Workflow::Create($newWorkflow);
    if($id){
      $newWorkflow['_id'] = $id;
      return new Workflow($newWorkflow);
    }
    return false;
  }

  public function isMilestone(){
    // check if is last task (automatically a milestone)
    // check if is milestone

  }

  public static function Create($data){
    // Create Job
    $jobData = array(
      'dateAdded' => new MongoDate(),
      'name' => $data['name'],
      'dueDate' => null,
      'approxEndDate' => null,
      'partiesInvolved' => array(),
      'nativeId' => _generate_unique_id(Job::CollectionName(), 'nativeId', 7),
      'organizationId' => isset($data['organizationId']) ? $data['organizationId'] : UserSession::Get_Organization()->id(),
      'viewableContacts' => array(),
      'meta' => array(),
      'notes' => array(),
      'workflowId' => _id($data['workflowId']),
      'sortOrder' => array()
    );
    $jobId = parent::Create($jobData);

    // Get Tasks Templates
    $workflow = Workflow::Get($data['workflowId']);
    $templates = $workflow->getTemplates();

    foreach($templates as $taskTemplate){
      $taskData = array(
        'dateAdded' => new MongoDate(),
        'taskTemplateId' => $taskTemplate->id(),
        'organizationId' => $jobData['organizationId'],
        'jobId' => $jobId,
        'workflowId' => $data['workflowId'],
        'activeUsers' => array(),
        'assigneeId' => array(),
        'triggers' => array(),
        'status' => 'new',
        'comments' => ''
      );
      Task::Create($taskData);
    }


    // Create Tasks
    return $jobId;
  }

  public function meta(){
    return $this->meta;
  }


}