<?php

require_once 'Meta.php';
require_once 'WorkflowFactory.php';

class Job extends WorkflowFactory
{

  /**
   * The collection that this record belongs to
   * @var string
   */
  protected static $_collection = 'jobs';

  private $tasks = array();

  private $sortOrder = array();

  /**
   * Meta class
   * @var null Meta
   */
  private $meta = null;

  protected static $_contactsField = 'partiesInvolved';

  public function __construct(array $data)
  {
    parent::__construct();
    $this->_initialize($data);
    $this->meta = new Meta($data['meta'], $this);
  }

  public function _initialize(array $data)
  {
    parent::_initialize($data); // TODO: Change the autogenerated stub
    $this->sortOrder = $this->getValue('sortOrder');
  }

  public function addTask(Task $task){
    if($this->hasId()){
      $task->setValues(array('jobId' => $this->id()))->save();
      $this->tasks[] = $task;
      $this->sort();
      return $this;
    } else {
      throw new Exception('Tasks can not be added without an _id');
    }
  }

  public function acknowledgeTask(Task $task){
    $this->tasks[] = $task;
    if(!in_array((string) $task->id(), $this->sortOrder)){
      $this->sortOrder[] = $task->id();
    }
  }

  public function sort(){
    $reorderedTasks = array();
    foreach((array) $this->sortOrder as $order => $id){
      foreach($this->tasks as $i => $task){
        if((string) $task->id() == (string) $id) $reorderedTasks[] = $task;
      }
    }
    $this->tasks = $reorderedTasks;
    return $this;
  }

  /**
   * Insert given task after the provided task
   * @param $taskId ID of the task being added
   * @param $afterTaskId The id of the task that will precede the given task
   */
  public function insertTaskAfter($taskId, $afterTaskId){
    $position = array_search((string) $afterTaskId, $this->sortOrder);
    array_splice($this->sortOrder, ($position+1), 0, array( _id($taskId)));
  }

  public function saveSortOrder(){
    if(json_encode($this->sortOrder) != json_encode($this->getValue('sortOrder'))){
      self::Update($this->id(), array(
        'sortOrder' => $this->sortOrder
      ));
    }
  }

  public function getAllTasks($grouped = false){
    if($this->hasId()){
      if(!empty($this->tasks)) return $this->tasks;
      else {
        $tasks = self::CI()->mdb->where('jobId', $this->id())->get(Task::CollectionName());
        foreach($tasks as $i => $task) $this->acknowledgeTask(new Task($task));
        $this->saveSortOrder();
        $this->sort();
        return $this->tasks;
      }
    } else {
      throw new Exception('Tasks can not be pulled without an _id');
    }
  }

  /**
   * Return all tasks that can be executed for the current job
   * @param bool $grouped Whether or not to return in an associated array grouped by "taskGroup"
   * @return array List of Task objects
   */
  public function getActionableTasks($grouped = false){
    $actionable = array();
    foreach($this->getAllTasks() as $i => $task){
      if($task->isActionable()) {
        if($grouped){
          if(!isset($actionable[$task->getValue('taskGroup')])) $actionable[$task->getValue('taskGroup')] = array();
          $actionable[$task->getValue('taskGroup')][] = $task;
        } else {
          $actionable[] = $task;
        }
      }
    }
    return $actionable;
  }

  /**
   * Return all tasks that can be displayed executed for the current job
   * @param bool $grouped Whether or not to return in an associated array grouped by "taskGroup"
   * @return array List of Task objects
   */
  public function getShowableTasks($grouped = false){
    $actionable = array();
    foreach($this->getAllTasks() as $i => $task){
      if($task->isShowable()) {
        if($grouped){
          if(!isset($actionable[$task->getValue('taskGroup')])) $actionable[$task->getValue('taskGroup')] = array();
          $actionable[$task->getValue('taskGroup')][] = $task;
        } else {
          $actionable[] = $task;
        }
      }
    }
    return $actionable;
  }

  /**
   * Return all tasks that can be displayed executed for the current job
   * @param bool $grouped Whether or not to return in an associated array grouped by "taskGroup"
   * @return array List of Task objects
   */
  public function getClientViewableTasks($grouped = false){
    $actionable = array();
    foreach($this->getAllTasks() as $i => $task){
      if($task->isClientViewable()) {
        if($grouped){
          if(!isset($actionable[$task->getValue('taskGroup')])) $actionable[$task->getValue('taskGroup')] = array();
          $actionable[$task->getValue('taskGroup')][] = $task;
        } else {
          $actionable[] = $task;
        }
      }
    }
    return $actionable;
  }

  public static function CompletionPercentage(array $taskSet){
    $completedCount = 0;
    $taskCount = 0;
    foreach($taskSet as $task) {
      $taskCount ++;
      if($task->isComplete()) $completedCount++;
    }
    return round(($completedCount/$taskCount) * 100);
  }

  public function getContacts(){
    $contacts = $this->getValue(self::$_contactsField);
    $roles = array();
    $contactIds = array();
    $userIds = array();
    foreach($contacts as $contact) {
      $userType = null;
      if(isset($contact['contactId'])) {
        $contactIds[] = $contact['contactId'];
        $userType = 'contactId';
      }
      if(isset($contact['userId'])) {
        $userIds[] = $contact['userId'];
        $userType = 'userId';
      }
      $roles[(string) $contact[$userType]] = $contact['role'];
    }
    $contacts = Contact::GetByIds($contactIds);
    $users = User::GetByIds($userIds);
    foreach($contacts as $i => $contact) if(isset($roles[(string) $contact->id()])) $contacts[$i]->setValue('role', $roles[(string) $contact->id()]);
    foreach($users as $i => $user) if(isset($roles[(string) $user->id()])) $users[$i]->setValue('role', $roles[(string) $user->id()]);

    return array_merge($contacts, $users);
  }

  /**
   * Get task object from tasks list instead of calling from db
   * @param $id
   * @return bool|mixed
   */
  public function getTaskById($id){
    foreach($this->tasks as $task) if((string) $task->id() == (string) $id) return $task;
    return false;
  }

  public function getCurrentTask(){
    $tasks = $this->getActionableTasks();
    foreach($tasks as $task) if(!$task->isComplete()) return $task;
  }
  
  public function getMeta(){
    return $this->meta->getAll();
    //return $this->getValue('meta');
  }

  public function addContactById($contact_or_user_id, $role, $isClient = false, $isContact = true){
    $contactsField = 'partiesInvolved';
    $contacts = $this->getValue($contactsField);
    $contacts = array_values($contacts);
    $userType = $isContact ? 'contactId' : 'userId';
    $contacts[] = array(
      $userType => _id($contact_or_user_id),
      'role' => $role,
      'isClient' => (bool) $isClient,
    );
    $this->setValue($contactsField, $contacts)->save($contactsField);
    return $this;
  }

  /**
   * Check if the passed id is a contact of $this job
   * @param $contact_or_user_id
   * @param bool $isContact
   * @return bool
   */
  public function isContact($contact_or_user_id, $isContact = true){
    $contactsField = 'partiesInvolved';
    $contacts = $this->getValue($contactsField);
    $userType = $isContact ? 'contactId' : 'userId';
    foreach($contacts as $contact) if((string) $contact[$userType] == (string) $contact_or_user_id) return true;
    return false;
  }

  public function removeContact($contactId){
    $save = false;
    $contactsField = 'partiesInvolved';
    $contacts = $this->getValue($contactsField);
    foreach($contacts as $i => $contact){
      if($contact['contactId'] == _id($contactId)) {
        $save = true;
        unset($contacts[$i]);
      }
    }
    if($save){
      $this->setValue($contactsField, $contacts)->save($contactsField);
    }
    return $this;
  }

  public function updateContactRole($contactId, $role){
    $save = false;
    $contactsField = 'partiesInvolved';
    $contacts = $this->getValue($contactsField);
    foreach($contacts as $i => $contact){
      if($contact['contactId'] == _id($contactId)) {
        $save = true;
        $contacts[$i]['role'] = $role;
      }
    }
    if($save){
      $this->setValue($contactsField, $contacts)->save($contactsField);
    }
    return $this;
  }

  public function getUrl(){
    return site_url('jobs/' . $this->id() . '/tasks');
  }

  public static function Get($id){
    $record = static::LoadId($id, static::$_collection);
    $class = __CLASS__;
    return new $class($record);
  }

  public function saveAsTemplate($name, $description = "", $group = "General"){
    $this->loadWorkflow();
    $newWorkflow = array(
      'name' => $name,
      'description' => $description,
      'organizationId' => UserSession::Get_Organization()->id(),
      'group' => $group ? $group : $this->workflow->getValue('group'),
      'roles' => $this->workflow->getValue('roles'),
      'status' => 'active',
      'taskTemplates' => array(),
      'accessibility' => array(),
      'metaFields' => $this->workflow->getValue('metaFields'),
    );

    // Add Task Templates
    $tasks = $this->getAllTasks();
    foreach($tasks as $task) $newWorkflow['taskTemplates'][] = $task->getValue('taskTemplateId');
    $id = Workflow::Create($newWorkflow);
    if($id){
      $newWorkflow['_id'] = $id;
      return new Workflow($newWorkflow);
    }
    return false;
  }

  public function isMilestone(){
    // check if is last task (automatically a milestone)
    // check if is milestone

  }

  public function meta(){
    return $this->meta;
  }


}